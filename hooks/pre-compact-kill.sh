#!/bin/bash
# ~/.claude/engine/hooks/pre-compact-kill.sh — PreCompact hook
#
# Intercepts auto-compaction to prevent lossy context compression.
# Flow:
#   1. Find active session via session.sh find
#   2. Check for DEHYDRATED_CONTEXT.md — generate mini-dehydration if missing
#   3. Delegate to session.sh restart (marks state, signals watchdog)
#
# This hook cannot BLOCK compaction (PreCompact doesn't support blocking).
# Instead, it races against the compaction by marking state and triggering
# a kill+restart. The watchdog (if running) handles the actual SIGKILL.
# Without a watchdog, the restart prompt is written for manual recovery.
#
# Matcher: "auto" only (manual /compact is intentional — don't interfere)
# TEST_MODE=1 for dry-run (prints actions, no kill)
#
# Related:
#   session.sh restart — marks killRequested, writes restartPrompt, signals watchdog
#   overflow-v2.sh — dehydrates at 76% (belt), this is the suspenders at ~95%
#   ¶INV_TMUX_AND_FLEET_OPTIONAL — works without tmux

set -euo pipefail

source "$HOME/.claude/scripts/lib.sh"

# Read hook input
INPUT=$(cat)
MATCHER=$(echo "$INPUT" | jq -r '.event // ""' 2>/dev/null || echo "")

# Only intercept auto-compaction, not manual /compact
if [ "$MATCHER" = "manual" ]; then
  exit 0
fi

# --- Step 1: Find active session ---
SESSION_DIR=""
SESSION_DIR=$("$HOME/.claude/scripts/session.sh" find 2>/dev/null) || true

if [ -z "$SESSION_DIR" ] || [ ! -f "$SESSION_DIR/.state.json" ]; then
  # No session = nothing to preserve
  if [ "${TEST_MODE:-}" = "1" ]; then
    echo "TEST: No active session found. Exiting."
  fi
  exit 0
fi

STATE_FILE="$SESSION_DIR/.state.json"

# --- Step 2: Check for dehydrated context ---
DEHY_FILE="$SESSION_DIR/DEHYDRATED_CONTEXT.md"

if [ ! -f "$DEHY_FILE" ]; then
  # Generate mini-dehydration from .state.json
  TASK_SUMMARY=$(jq -r '.taskSummary // "Unknown task"' "$STATE_FILE")
  CURRENT_PHASE=$(jq -r '.currentPhase // "Unknown"' "$STATE_FILE")
  SKILL=$(jq -r '.skill // "unknown"' "$STATE_FILE")

  # List session artifacts
  ARTIFACTS=""
  for f in "$SESSION_DIR"/*.md; do
    [ -f "$f" ] || continue
    ARTIFACTS="${ARTIFACTS}- $(basename "$f")\n"
  done

  if [ "${TEST_MODE:-}" = "1" ]; then
    echo "TEST: Generating mini-dehydration at $DEHY_FILE"
  fi

  cat > "$DEHY_FILE" <<DEHYDEOF
# DEHYDRATED CONTEXT (Auto-Generated by PreCompact Hook)

## The "Big Picture"
*   **Ultimate Goal**: $TASK_SUMMARY
*   **Status**: $CURRENT_PHASE

## Last Action Report
*   **Last Task**: PreCompact hook triggered — auto-compaction intercepted
*   **Outcome**: Session killed to prevent lossy compression
*   **State**: Unknown — check session artifacts

## Handover Instructions
1. Reuse session \`$SESSION_DIR\`
2. Resume at $CURRENT_PHASE
3. Check session artifacts for detailed state

## Required Files (Context List)

### Session Artifacts (MANDATORY)
$(echo -e "$ARTIFACTS")
### Engine Standards (auto-injectable)
- ~/.claude/.directives/COMMANDS.md
- ~/.claude/.directives/INVARIANTS.md
- ~/.claude/.directives/TAGS.md
DEHYDEOF
fi

# --- Step 3: Delegate to session.sh restart ---
# session.sh restart handles: mark killRequested, write restartPrompt, signal watchdog
if [ "${TEST_MODE:-}" = "1" ]; then
  echo "TEST: Would call session.sh restart $SESSION_DIR"
  echo "TEST: Session dir: $SESSION_DIR"
  echo "TEST: Dehydrated context: $([ -f "$DEHY_FILE" ] && echo "exists" || echo "missing")"
  exit 0
fi

"$HOME/.claude/scripts/session.sh" restart "$SESSION_DIR" 2>/dev/null || true

exit 0
